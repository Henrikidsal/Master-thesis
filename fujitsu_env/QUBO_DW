##### This is a script that solves the continous version of the UCP
##### It uses Benders Decomposition. The master problem is a QUBO solved by D-Wave's BQM solver.
##### The subproblem is a continuous LP solved using Pyomo/Gurobi.
##### All constraints in master problem; Logic 1, Logic 2, optimality cuts and feasibility cuts are penalty terms in the QUBO objective.
##### All variables in the master problem are binary. Beta and slack variables are binary encoded.
##### Feasibility cuts use FarkasDual attributes obtained via gurobi_persistent.

##### Neccecary imports
import pyomo.environ as pyo
from pyomo.environ import *
from pyomo.opt import SolverFactory, TerminationCondition
import time
import dimod
from dwave.system import LeapHybridSampler
import numpy as np



# Choose the number of time periods wanted:
Periods = 3
# Sets
generators = [1, 2, 3]
time_periods = [x for x in range(1, Periods+1)] # T=3 hours

# Generator Parameters
gen_data = {
    1: {'Pmin': 50,  'Pmax': 350, 'Rd': 300, 'Rsd': 300, 'Ru': 200, 'Rsu': 200, 'Cf': 5, 'Csu': 20, 'Csd': 0.5, 'Cv': 0.100},
    2: {'Pmin': 80,  'Pmax': 200, 'Rd': 150, 'Rsd': 150, 'Ru': 100, 'Rsu': 100, 'Cf': 7, 'Csu': 18, 'Csd': 0.3, 'Cv': 0.125},
    3: {'Pmin': 40,  'Pmax': 140, 'Rd': 100, 'Rsd': 100, 'Ru': 100, 'Rsu': 100, 'Cf': 6, 'Csu': 5,  'Csd': 1.0, 'Cv': 0.150}
}

# Demand Parameters
demand = {1: 160, 2: 500, 3: 400} # Demand for each time period

# Initial Conditions for time period = 0
u_initial = {1: 0, 2: 0, 3: 1}
p_initial = {1: 0, 2: 0, 3: 100}

# Number of bits for variable encoding
num_beta_bits = 7
num_slack_bits = 10
slack_step_length = 0.5

# Penalty parameters for the QUBO master problem
lambda_logic1 = 20
lambda_logic2 = 1
lambda_opt_cut = 5
lambda_feas_cut = 1

def build_subproblem(u_fixed_vals, zON_fixed_vals, zOFF_fixed_vals):
    model = pyo.ConcreteModel(name="Sub Problem")
    model.I = pyo.Set(initialize=generators)
    model.T = pyo.Set(initialize=time_periods)
    u_fixed_param_vals = {(i,t): u_fixed_vals.get((i,t), 0) for i in model.I for t in model.T}
    zON_fixed_param_vals = {(i,t): zON_fixed_vals.get((i,t), 0) for i in model.I for t in model.T}
    zOFF_fixed_param_vals = {(i,t): zOFF_fixed_vals.get((i,t), 0) for i in model.I for t in model.T}
    model.u_fixed = pyo.Param(model.I, model.T, initialize=u_fixed_param_vals)
    model.zON_fixed = pyo.Param(model.I, model.T, initialize=zON_fixed_param_vals)
    model.zOFF_fixed = pyo.Param(model.I, model.T, initialize=zOFF_fixed_param_vals)
    model.Pmin = pyo.Param(model.I, initialize={i: gen_data[i]['Pmin'] for i in model.I})
    model.Pmax = pyo.Param(model.I, initialize={i: gen_data[i]['Pmax'] for i in model.I})
    model.Rd = pyo.Param(model.I, initialize={i: gen_data[i]['Rd'] for i in model.I})
    model.Rsd = pyo.Param(model.I, initialize={i: gen_data[i]['Rsd'] for i in model.I})
    model.Ru = pyo.Param(model.I, initialize={i: gen_data[i]['Ru'] for i in model.I})
    model.Rsu = pyo.Param(model.I, initialize={i: gen_data[i]['Rsu'] for i in model.I})
    model.Cv = pyo.Param(model.I, initialize={i: gen_data[i]['Cv'] for i in model.I})
    model.D = pyo.Param(model.T, initialize=demand)
    model.u_init = pyo.Param(model.I, initialize=u_initial)
    model.p_init = pyo.Param(model.I, initialize=p_initial)
    model.p = pyo.Var(model.I, model.T, within=pyo.NonNegativeReals)
    model.OBJ = pyo.Objective(rule=lambda m: sum(m.Cv[i] * m.p[i, t] for i in m.I for t in m.T), sense=pyo.minimize)
    model.p_prev = pyo.Expression(model.I, model.T, rule=lambda m, i, t: m.p_init[i] if t == 1 else m.p[i, t-1])
    model.u_prev_fixed = pyo.Expression(model.I, model.T, rule=lambda m, i, t: m.u_init[i] if t == 1 else m.u_fixed[i, t-1])
    model.MinPower = pyo.Constraint(model.I, model.T, rule=lambda m, i, t: m.Pmin[i] * m.u_fixed[i, t] <= m.p[i, t])
    model.MaxPower = pyo.Constraint(model.I, model.T, rule=lambda m, i, t: m.p[i, t] <= m.Pmax[i] * m.u_fixed[i, t])
    model.RampUp = pyo.Constraint(model.I, model.T, rule=lambda m,i,t: m.p[i,t] - m.p_prev[i,t] <= m.Ru[i] * m.u_prev_fixed[i,t] + m.Rsu[i] * m.zON_fixed[i, t])
    model.RampDown = pyo.Constraint(model.I, model.T, rule=lambda m,i,t: m.p_prev[i,t] - m.p[i,t] <= m.Rd[i] * m.u_fixed[i,t] + m.Rsd[i] * m.zOFF_fixed[i,t])
    model.Demand = pyo.Constraint(model.T, rule=lambda m, t: sum(m.p[i, t] for i in m.I) >= m.D[t])
    model.dual = pyo.Suffix(direction=pyo.Suffix.IMPORT)
    return model


def build_master_bqm(iteration_data):
    bqm = dimod.BinaryQuadraticModel(dimod.BINARY)

    # Define variable names
    u_vars = {(i, t): f"u_{i}_{t}" for i in generators for t in time_periods}
    zON_vars = {(i, t): f"zON_{i}_{t}" for i in generators for t in time_periods}
    zOFF_vars = {(i, t): f"zOFF_{i}_{t}" for i in generators for t in time_periods}
    beta_vars = {j: f"beta_{j}" for j in range(num_beta_bits)}
    opt_cut_indices = [k for k, data in enumerate(iteration_data) if data['type'] == 'optimality']
    feas_cut_indices = [k for k, data in enumerate(iteration_data) if data['type'] == 'feasibility']
    slack_opt_vars = {(k, l): f"s_opt_{k}_{l}" for k in opt_cut_indices for l in range(num_slack_bits)}
    slack_feas_vars = {(k, l): f"s_feas_{k}_{l}" for k in feas_cut_indices for l in range(num_slack_bits)}

    # 1. Commitment Cost and Beta (Linear Terms)
    for i in generators:
        for t in time_periods:
            bqm.add_linear(u_vars[i,t], gen_data[i]['Cf'])
            bqm.add_linear(zON_vars[i,t], gen_data[i]['Csu'])
            bqm.add_linear(zOFF_vars[i,t], gen_data[i]['Csd'])
    for j in range(num_beta_bits):
        bqm.add_linear(beta_vars[j], 2**j)

    # 2. Logic Penalties (Quadratic Terms)
    for i in generators:
        for t in time_periods:
            bqm.add_quadratic(zON_vars[i,t], zOFF_vars[i,t], lambda_logic2)
            
            logic1_expr = dimod.BinaryQuadraticModel(dimod.BINARY)
            logic1_expr.add_linear(u_vars[i,t], 1)
            logic1_expr.add_linear(zON_vars[i,t], -1)
            logic1_expr.add_linear(zOFF_vars[i,t], 1)
            if t > 1:
                logic1_expr.add_linear(u_vars[i, t-1], -1)
            else:
                logic1_expr.offset = -u_initial[i]
            
            # **FIX**: Use the += operator to add the squared model to the main BQM.
            bqm += lambda_logic1 * (logic1_expr**2)

    # 3. Benders Cut Penalties
    for k_idx in opt_cut_indices:
        cut_expr, const = get_optimality_cut_expr(iteration_data[k_idx], u_vars, zON_vars, zOFF_vars, beta_vars, slack_opt_vars, k_idx)
        cut_expr.offset += const
        bqm += lambda_opt_cut * (cut_expr**2)

    for k_idx in feas_cut_indices:
        cut_expr, const = get_feasibility_cut_expr(iteration_data[k_idx], u_vars, zON_vars, zOFF_vars, slack_feas_vars, k_idx)
        cut_expr.offset += const
        bqm += lambda_feas_cut * (cut_expr**2)

    return bqm

def get_optimality_cut_expr(data, u_vars, zON_vars, zOFF_vars, beta_vars, slack_vars, k_idx):
    """Helper to build the expression for an optimality cut: (beta - slack - cut_rhs)"""
    expr = dimod.BinaryQuadraticModel(dimod.BINARY)
    const = 0
    
    # beta term
    for j in range(num_beta_bits):
        expr.add_linear(beta_vars[j], 2**j)
    # -slack term
    for l in range(num_slack_bits):
        expr.add_linear(slack_vars[k_idx,l], -slack_step_length * (2**l))

    # -cut_rhs term
    duals = data['duals']; u_k = data['u_vals']; zON_k = data['zON_vals']; zOFF_k = data['zOFF_vals']
    const -= data['sub_obj']
    for i in generators:
        for t in time_periods:
            const += duals['lambda_min'].get((i, t), 0) * gen_data[i]['Pmin'] * u_k.get((i, t), 0)
            expr.add_linear(u_vars[i, t], -duals['lambda_min'].get((i,t),0)*gen_data[i]['Pmin'])

            const += duals['lambda_max'].get((i, t), 0) * gen_data[i]['Pmax'] * u_k.get((i, t), 0)
            expr.add_linear(u_vars[i, t], -duals['lambda_max'].get((i,t),0)*gen_data[i]['Pmax'])
            
            u_prev_k = u_initial[i] if t==1 else u_k.get((i,t-1),0)
            const += duals['lambda_ru'].get((i, t), 0) * (gen_data[i]['Ru'] * u_prev_k + gen_data[i]['Rsu'] * zON_k.get((i,t),0))
            if t > 1: expr.add_linear(u_vars[i,t-1], -duals['lambda_ru'].get((i,t),0)*gen_data[i]['Ru'])
            expr.add_linear(zON_vars[i, t], -duals['lambda_ru'].get((i,t),0)*gen_data[i]['Rsu'])

            const += duals['lambda_rd'].get((i, t), 0) * (gen_data[i]['Rd'] * u_k.get((i,t),0) + gen_data[i]['Rsd'] * zOFF_k.get((i,t),0))
            expr.add_linear(u_vars[i, t], -duals['lambda_rd'].get((i,t),0)*gen_data[i]['Rd'])
            expr.add_linear(zOFF_vars[i, t], -duals['lambda_rd'].get((i,t),0)*gen_data[i]['Rsd'])

    return expr, const

def get_feasibility_cut_expr(data, u_vars, zON_vars, zOFF_vars, slack_vars, k_idx):
    expr = dimod.BinaryQuadraticModel(dimod.BINARY)
    const = 0
    rays = data['rays']
    
    # slack term
    for l in range(num_slack_bits):
        expr.add_linear(slack_vars[k_idx,l], slack_step_length * (2**l))
    
    # -cut_lhs term
    for i in generators:
        for t in time_periods:
            expr.add_linear(u_vars[i,t], -rays['min_power'].get((i,t),0)*gen_data[i]['Pmin'])
            expr.add_linear(u_vars[i,t], -rays['max_power'].get((i,t),0)*gen_data[i]['Pmax'])
            if t > 1: expr.add_linear(u_vars[i,t-1], -rays['ramp_up'].get((i,t),0)*gen_data[i]['Ru'])
            else: const -= rays['ramp_up'].get((i,t),0)*gen_data[i]['Ru']*u_initial[i]
            expr.add_linear(zON_vars[i,t], -rays['ramp_up'].get((i,t),0)*gen_data[i]['Rsu'])
            expr.add_linear(u_vars[i,t], -rays['ramp_down'].get((i,t),0)*gen_data[i]['Rd'])
            expr.add_linear(zOFF_vars[i,t], -rays['ramp_down'].get((i,t),0)*gen_data[i]['Rsd'])
    for t in time_periods:
        const -= rays['demand'].get(t,0)*demand[t]
        
    return expr, const

def check_master_solution_feasibility(sample, iteration_data):
    total_penalty = 0
    
    # Logic 1 & 2 Penalties
    logic1_penalty = 0; logic2_penalty = 0
    for i in generators:
        for t in time_periods:
            u_it = sample.get(f"u_{i}_{t}", 0)
            u_prev = u_initial[i] if t == 1 else sample.get(f"u_{i}_{t-1}", 0)
            zON_it = sample.get(f"zON_{i}_{t}", 0)
            zOFF_it = sample.get(f"zOFF_{i}_{t}", 0)
            logic1_penalty += (u_it - u_prev - zON_it + zOFF_it)**2
            logic2_penalty += zON_it * zOFF_it
    total_penalty += lambda_logic1 * logic1_penalty
    total_penalty += lambda_logic2 * logic2_penalty
    
    # Benders Cuts Penalties
    opt_cut_penalty = 0
    opt_cut_indices = [k for k, data in enumerate(iteration_data) if data['type'] == 'optimality']
    for k_idx in opt_cut_indices:
        data = iteration_data[k_idx]
        beta_val = sum((2**j) * sample.get(f"beta_{j}", 0) for j in range(num_beta_bits))
        slack_val = sum(slack_step_length * (2**l) * sample.get(f"s_opt_{k_idx}_{l}", 0) for l in range(num_slack_bits))
        
        cut_rhs_val = data['sub_obj']
        for i in generators:
            for t in time_periods:
                u_it = sample.get(f"u_{i}_{t}", 0); u_k_it = data['u_vals'].get((i,t),0)
                u_prev = u_initial[i] if t==1 else sample.get(f"u_{i}_{t-1}",0); u_k_prev = u_initial[i] if t==1 else data['u_vals'].get((i,t-1),0)
                zON_it = sample.get(f"zON_{i}_{t}",0); zON_k_it = data['zON_vals'].get((i,t),0)
                zOFF_it = sample.get(f"zOFF_{i}_{t}",0); zOFF_k_it = data['zOFF_vals'].get((i,t),0)
                duals = data['duals']
                cut_rhs_val += duals['lambda_min'].get((i,t),0) * gen_data[i]['Pmin'] * (u_it - u_k_it)
                cut_rhs_val += duals['lambda_max'].get((i,t),0) * gen_data[i]['Pmax'] * (u_it - u_k_it)
                cut_rhs_val += duals['lambda_ru'].get((i,t),0) * (gen_data[i]['Ru']*(u_prev - u_k_prev) + gen_data[i]['Rsu']*(zON_it - zON_k_it))
                cut_rhs_val += duals['lambda_rd'].get((i,t),0) * (gen_data[i]['Rd']*(u_it - u_k_it) + gen_data[i]['Rsd']*(zOFF_it - zOFF_k_it))
        
        opt_cut_penalty += (beta_val - slack_val - cut_rhs_val)**2
    total_penalty += lambda_opt_cut * opt_cut_penalty
    
    # (A full implementation would also check feasibility cuts here)
    
    return total_penalty

def main():
    start_time = time.time()
    max_iter = 30
    epsilon = 1
    iteration_data = []
    lower_bound = -float('inf')
    upper_bound = float('inf')

    # Initial guess
    u_current = { (i,t):1.0 for i in generators for t in time_periods}
    zON_current = { (i,t):1.0 if t==1 and u_initial[i]==0 else 0.0 for i in generators for t in time_periods }
    zOFF_current = { (i,t):0.0 for i in generators for t in time_periods }

    sub_solver = SolverFactory("gurobi_persistent", solver_io='python')

    print(f"--- Starting Benders Decomposition for UCP ---")
    print(f"Master Solver: D-Wave BQM Solver, Subproblem Solver: Gurobi")
    print(f"Max Iterations: {max_iter}, Tolerance: {epsilon}\n")

    k_iter_count = 0
    best_solution_for_ub_display = None

    for k_loop_idx in range(1, max_iter + 1):
        k_iter_count = k_loop_idx
        print(f"========================= Iteration {k_iter_count} =========================")

        # --- Subproblem Solve ---
        print("--- Solving Subproblem ---")
        subproblem = build_subproblem(u_current, zON_current, zOFF_current)
        sub_solver.set_instance(subproblem)
        sub_solver.set_gurobi_param('InfUnbdInfo', 1)
        sub_solver.set_gurobi_param('DualReductions', 0)
        results = sub_solver.solve(tee=False)
        
        is_infeasible = results.solver.termination_condition == TerminationCondition.infeasible
        sub_obj_val = pyo.value(subproblem.OBJ) if not is_infeasible else float('nan')

        if not is_infeasible:
            print(f"Subproblem Status: Optimal, Objective: {sub_obj_val:.4f}")
            commitment_cost = sum(gen_data[i]['Csu'] * zON_current.get((i,t),0) + gen_data[i]['Csd'] * zOFF_current.get((i,t),0) + gen_data[i]['Cf'] * u_current.get((i,t),0) for i in generators for t in time_periods)
            current_total_cost = commitment_cost + sub_obj_val
            if current_total_cost < upper_bound:
                upper_bound = current_total_cost
                best_solution_for_ub_display = {'u_vals': u_current.copy(), 'zON_vals': zON_current.copy(), 'zOFF_vals': zOFF_current.copy(), 'iter': k_iter_count, 'total_cost': upper_bound}
                print(f"New Best Upper Bound (Z_UB): {upper_bound:.4f}")
            duals_for_cut = {'lambda_min': {}, 'lambda_max': {}, 'lambda_ru': {}, 'lambda_rd': {}}
            for i in generators:
                for t in time_periods:
                    duals_for_cut['lambda_min'][(i,t)] = subproblem.dual.get(subproblem.MinPower[i,t], 0.0)
                    duals_for_cut['lambda_max'][(i,t)] = subproblem.dual.get(subproblem.MaxPower[i,t], 0.0)
                    duals_for_cut['lambda_ru'][(i,t)]  = subproblem.dual.get(subproblem.RampUp[i,t], 0.0)
                    duals_for_cut['lambda_rd'][(i,t)]  = subproblem.dual.get(subproblem.RampDown[i,t], 0.0)
            iteration_data.append({'type': 'optimality', 'sub_obj': sub_obj_val, 'duals': duals_for_cut, 'u_vals': u_current.copy(), 'zON_vals': zON_current.copy(), 'zOFF_vals': zOFF_current.copy()})
        else:
            print("Subproblem Status: INFEASIBLE. Generating Feasibility Cut.")
            rays_for_cut = {'min_power': {}, 'max_power': {}, 'ramp_up': {}, 'ramp_down': {}, 'demand': {}}
            for c in subproblem.component_data_objects(Constraint, active=True):
                ray_val = sub_solver.get_linear_constraint_attr(c, 'FarkasDual') or 0.0
                parent = c.parent_component(); idx = c.index()
                if parent is subproblem.MinPower: rays_for_cut['min_power'][idx] = ray_val
                elif parent is subproblem.MaxPower: rays_for_cut['max_power'][idx] = ray_val
                elif parent is subproblem.RampUp: rays_for_cut['ramp_up'][idx] = ray_val
                elif parent is subproblem.RampDown: rays_for_cut['ramp_down'][idx] = ray_val
                elif parent is subproblem.Demand: rays_for_cut['demand'][idx] = ray_val
            iteration_data.append({'type': 'feasibility', 'rays': rays_for_cut, 'u_vals': u_current.copy(), 'zON_vals': zON_current.copy(), 'zOFF_vals': zOFF_current.copy()})

        # --- Convergence Check ---
        print(f"Current Lower Bound (Z_LB): {lower_bound:.4f}, Current Upper Bound (Z_UB): {upper_bound:.4f}")
        if upper_bound - lower_bound <= epsilon and k_iter_count > 1:
            print("\nConvergence tolerance met.")
            break
        if k_iter_count == max_iter:
            print("\nMaximum iterations reached.")
            break
        
        # --- Master Problem Solve with D-Wave ---
        print("\n--- Building and Solving Master Problem with D-Wave ---")
        master_bqm = build_master_bqm(iteration_data)
        
        feasible_master_solution_found = False
        for attempt in range(1, 3):
            print(f"D-Wave master solve attempt {attempt}...")
            try:
                sampler = LeapHybridSampler()
                sampleset = sampler.sample(master_bqm, num_reads=100, label=f"UCP_Master_Iter_{k_iter_count}")
                if not sampleset: 
                    print("D-Wave sampler returned no samples.")
                    continue
                sample = sampleset.first.sample
            except Exception as e:
                print(f"D-Wave API call failed: {e}. You may need to configure your API token. Skipping attempt.")
                continue

            penalty_value = check_master_solution_feasibility(sample, iteration_data)
            print(f"D-Wave returned a solution with energy {sampleset.first.energy:.2f}. Calculated penalty: {penalty_value:.4f}")
            
            pen_tol = 1e-3
            if penalty_value < pen_tol:
                print("Solution is feasible (penalties are small).")
                commitment_cost = sum(gen_data[i]['Cf'] * sample[f"u_{i}_{t}"] + gen_data[i]['Csu'] * sample[f"zON_{i}_{t}"] + gen_data[i]['Csd'] * sample[f"zOFF_{i}_{t}"] for i in generators for t in time_periods)
                beta_val = sum((2**j) * sample[f"beta_{j}"] for j in range(num_beta_bits))
                
                lower_bound_candidate = commitment_cost + beta_val
                lower_bound = max(lower_bound, lower_bound_candidate)
                print(f"Updated Lower Bound (Z_LB): {lower_bound:.4f}")

                u_current = {(i,t): float(sample[f"u_{i}_{t}"]) for i in generators for t in time_periods}
                zON_current = {(i,t): float(sample[f"zON_{i}_{t}"]) for i in generators for t in time_periods}
                # **FIX**: Corrected the loop for zOFF_current to iterate over generators and time_periods.
                zOFF_current = {(i,t): float(sample[f"zOFF_{i}_{t}"]) for i in generators for t in time_periods}
                feasible_master_solution_found = True
                break
            else:
                print("Solution is not feasible (penalties are too high). Retrying...")

        if not feasible_master_solution_found:
            print("Master problem solver could not find a feasible solution after 2 tries. Terminating.")
            break

    # --- Final Report ---
    end_time = time.time()
    print("\n========================= Benders Terminated =========================")
    print(f"Final Lower Bound (Z_LB): {lower_bound:.4f}")
    print(f"Final Upper Bound (Z_UB): {upper_bound:.4f}")
    print(f"Total Time: {end_time - start_time:.2f} seconds")
    if best_solution_for_ub_display:
        print(f"\n--- Best Feasible Solution Found (leading to best Z_UB in iter {best_solution_for_ub_display['iter']}) ---")
        final_subproblem = build_subproblem(best_solution_for_ub_display['u_vals'], best_solution_for_ub_display['zON_vals'], best_solution_for_ub_display['zOFF_vals'])
        final_sub_solver = SolverFactory('gurobi')
        final_sub_results = final_sub_solver.solve(final_subproblem)
        if final_sub_results.solver.termination_condition == TerminationCondition.optimal:
             final_var_cost = pyo.value(final_subproblem.OBJ)
             final_commit_cost = sum(gen_data[i]['Csu'] * best_solution_for_ub_display['zON_vals'].get((i,t),0) + gen_data[i]['Csd'] * best_solution_for_ub_display['zOFF_vals'].get((i,t),0) + gen_data[i]['Cf'] * best_solution_for_ub_display['u_vals'].get((i,t),0) for i in generators for t in time_periods)
             print(f"Best Total Cost (Upper Bound): {final_commit_cost + final_var_cost:.4f}")
             print("Commitment Schedule (u_it):")
             for t in time_periods: print(f"  t={t}: ", {i: round(best_solution_for_ub_display['u_vals'].get((i,t),0)) for i in generators})
             print("\nFinal Dispatch (p_it):")
             for t in time_periods: print(f"    t={t}: ", {i: f"{pyo.value(final_subproblem.p[i,t]):.2f}" for i in generators})
    else:
        print("\nNo feasible solution found.")
        
if __name__ == '__main__':
    main()