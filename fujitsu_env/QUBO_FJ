##### This is a script that solves the continous version of the UCP
##### It uses Benders Decomposition.
##### The master problem is a QUBO solved by Fujitsu's Digital Annealer (dadk).
##### The subproblem is a continuous LP solved using Pyomo/Gurobi.
##### All constraints in master problem; Logic 1, Logic 2, optimality cuts and feasibility cuts are penalty terms in the QUBO objective.
##### All variables in the master problem are binary. Beta and slack variables are binary encoded.
##### Feasibility cuts use FarkasDual attributes obtained via gurobi_persistent.

##### Neccecary imports
import pyomo.environ as pyo
from pyomo.environ import *
from pyomo.opt import SolverFactory, TerminationCondition
import time
import numpy as np
from dadk.BinPol import *
from dadk.QUBOSolverCPU import QUBOSolverCPU, ScalingAction


# Choose the number of time periods wanted:
Periods = 3
# Sets
generators = [1, 2, 3]
time_periods = [x for x in range(1, Periods+1)] # T=3 hours

# Generator Parameters
gen_data = {
    1: {'Pmin': 50,  'Pmax': 350, 'Rd': 300, 'Rsd': 300, 'Ru': 200, 'Rsu': 200, 'Cf': 5, 'Csu': 20, 'Csd': 0.5, 'Cv': 0.100},
    2: {'Pmin': 80,  'Pmax': 200, 'Rd': 150, 'Rsd': 150, 'Ru': 100, 'Rsu': 100, 'Cf': 7, 'Csu': 18, 'Csd': 0.3, 'Cv': 0.125},
    3: {'Pmin': 40,  'Pmax': 140, 'Rd': 100, 'Rsd': 100, 'Ru': 100, 'Rsu': 100, 'Cf': 6, 'Csu': 5,  'Csd': 1.0, 'Cv': 0.150}
}

# Demand Parameters
demand = {1: 160, 2: 500, 3: 400} # Demand for each time period

# Initial Conditions for time period = 0
u_initial = {1: 0, 2: 0, 3: 1}
p_initial = {1: 0, 2: 0, 3: 100}

# Number of bits for variable encoding
num_beta_bits = 7
num_slack_bits = 10
slack_step_length = 0.5

# Penalty parameters for the QUBO master problem
lambda_logic1 = 2000
lambda_logic2 = 10
lambda_opt_cut = 50
lambda_feas_cut = 50

# Tolerance for checking if penalties are "small"
PENALTY_TOLERANCE = 1e-3

# This function creates the continous sub problem (LP) - UNCHANGED
def build_subproblem(u_fixed_vals, zON_fixed_vals, zOFF_fixed_vals):

    # Create a concrete model
    model = pyo.ConcreteModel(name="Sub Problem")

    # Define sets for generators and time periods
    model.I = pyo.Set(initialize=generators)
    model.T = pyo.Set(initialize=time_periods)

    # This part collects the master problem variables
    u_fixed_param_vals = {(i,t): u_fixed_vals[i,t] for i in model.I for t in model.T}
    zON_fixed_param_vals = {(i,t): zON_fixed_vals[i,t] for i in model.I for t in model.T}
    zOFF_fixed_param_vals = {(i,t): zOFF_fixed_vals[i,t] for i in model.I for t in model.T}

    # This part fixes the master problem variables to parameters.
    model.u_fixed = pyo.Param(model.I, model.T, initialize=u_fixed_param_vals)
    model.zON_fixed = pyo.Param(model.I, model.T, initialize=zON_fixed_param_vals)
    model.zOFF_fixed = pyo.Param(model.I, model.T, initialize=zOFF_fixed_param_vals)

    # Here the parameters for the problem are defined
    model.Pmin = pyo.Param(model.I, initialize={i: gen_data[i]['Pmin'] for i in model.I})
    model.Pmax = pyo.Param(model.I, initialize={i: gen_data[i]['Pmax'] for i in model.I})
    model.Rd = pyo.Param(model.I, initialize={i: gen_data[i]['Rd'] for i in model.I})
    model.Rsd = pyo.Param(model.I, initialize={i: gen_data[i]['Rsd'] for i in model.I})
    model.Ru = pyo.Param(model.I, initialize={i: gen_data[i]['Ru'] for i in model.I})
    model.Rsu = pyo.Param(model.I, initialize={i: gen_data[i]['Rsu'] for i in model.I})
    model.Cv = pyo.Param(model.I, initialize={i: gen_data[i]['Cv'] for i in model.I})
    model.D = pyo.Param(model.T, initialize=demand)
    model.u_init = pyo.Param(model.I, initialize=u_initial)
    model.p_init = pyo.Param(model.I, initialize=p_initial)

    # We only have this one variable in the sub problem, the power output of each generator
    model.p = pyo.Var(model.I, model.T, within=pyo.NonNegativeReals)

    # Objective function, minimizing the total cost of generation
    def objective_rule(m):
        return sum(m.Cv[i] * m.p[i, t] for i in m.I for t in m.T)
    model.OBJ = pyo.Objective(rule=objective_rule, sense=pyo.minimize)

    # just a clever way of always ensuring that we correctly uses the previous time periods power output
    def p_prev_rule(m, i, t):
        return m.p_init[i] if t == 1 else m.p[i, t-1]
    model.p_prev = pyo.Expression(model.I, model.T, rule=p_prev_rule)

    # A clever way of ennsuring that we uses the correct on/off state of the generator in each time period
    def u_prev_fixed_rule(m, i, t):
        return m.u_init[i] if t == 1 else m.u_fixed[i, t-1]
    model.u_prev_fixed = pyo.Expression(model.I, model.T, rule=u_prev_fixed_rule)

    # The constraints
    model.MinPower = pyo.Constraint(model.I, model.T, rule=lambda m, i, t: m.Pmin[i] * m.u_fixed[i, t] <= m.p[i, t])
    model.MaxPower = pyo.Constraint(model.I, model.T, rule=lambda m, i, t: m.p[i, t] <= m.Pmax[i] * m.u_fixed[i, t])
    model.RampUp = pyo.Constraint(model.I, model.T, rule=lambda m,i,t: m.p[i,t] - m.p_prev[i,t] <= m.Ru[i] * m.u_prev_fixed[i,t] + m.Rsu[i] * m.zON_fixed[i, t])
    model.RampDown = pyo.Constraint(model.I, model.T, rule=lambda m,i,t: m.p_prev[i,t] - m.p[i,t] <= m.Rd[i] * m.u_fixed[i,t] + m.Rsd[i] * m.zOFF_fixed[i,t])
    model.Demand = pyo.Constraint(model.T, rule=lambda m, t: sum(m.p[i, t] for i in m.I) >= m.D[t])

    # Collects dual variables for optimality cuts, and dual rays for feasibility cuts.
    model.dual = pyo.Suffix(direction=pyo.Suffix.IMPORT)
    return model

# Function to build the master problem QUBO using dadk
def build_master_qubo_dadk(iteration_data):

    opt_cut_indices = [k for k, data in enumerate(iteration_data) if data['type'] == 'optimality']
    feas_cut_indices = [k for k, data in enumerate(iteration_data) if data['type'] == 'feasibility']
    
    # Define variable shapes for dadk
    var_shapes = [
        BitArrayShape(name='u', shape=(len(generators), len(time_periods))),
        BitArrayShape(name='zon', shape=(len(generators), len(time_periods))),
        BitArrayShape(name='zoff', shape=(len(generators), len(time_periods))),
        BitArrayShape(name='beta', shape=(num_beta_bits,))
    ]
    if opt_cut_indices:
        var_shapes.append(BitArrayShape(name='s_opt', shape=(len(iteration_data), num_slack_bits)))
    if feas_cut_indices:
        var_shapes.append(BitArrayShape(name='s_feas', shape=(len(iteration_data), num_slack_bits)))
        
    var_shape_set = VarShapeSet(*var_shapes)
    BinPol.freeze_var_shape_set(var_shape_set)

    qubo = BinPol()

    # --- 1. Objective Function: Commitment Costs and Beta ---
    for i_idx, i_gen in enumerate(generators):
        for t_idx, t_period in enumerate(time_periods):
            qubo.add_term(gen_data[i_gen]['Cf'], ('u', i_idx, t_idx))
            qubo.add_term(gen_data[i_gen]['Csu'], ('zon', i_idx, t_idx))
            qubo.add_term(gen_data[i_gen]['Csd'], ('zoff', i_idx, t_idx))
            
    for j in range(num_beta_bits):
        qubo.add_term(2**j, ('beta', j))

    # --- 2. Logic Constraint Penalties ---
    for i_idx, i_gen in enumerate(generators):
        for t_idx, t_period in enumerate(time_periods):
            # Logic 2: zon * zoff = 0  => Penalty for zon=1 and zoff=1
            qubo.add_term(lambda_logic2, ('zon', i_idx, t_idx), ('zoff', i_idx, t_idx))
            
            # Logic 1: u_t - u_{t-1} = zon_t - zoff_t
            logic1_poly = BinPol()
            logic1_poly.add_term(1, ('u', i_idx, t_idx))
            logic1_poly.add_term(-1, ('zon', i_idx, t_idx))
            logic1_poly.add_term(1, ('zoff', i_idx, t_idx))
            
            if t_period == 1:
                logic1_poly.add_term(-u_initial[i_gen]) # Constant term
            else:
                logic1_poly.add_term(-1, ('u', i_idx, t_idx - 1))
            
            qubo.add(logic1_poly.power(2), lambda_logic1)

    # --- 3. Benders Optimality Cut Penalties ---
    for k_idx in opt_cut_indices:
        data = iteration_data[k_idx]
        duals_k = data['duals']
        u_k, zON_k, zOFF_k = data['u_vals'], data['zON_vals'], data['zOFF_vals']

        # Expression is (beta - cut_rhs - slack)^2
        cut_poly = BinPol()
        
        # Add beta term: sum(2^j * beta_j)
        for j in range(num_beta_bits):
            cut_poly.add_term(2**j, ('beta', j))
        
        # Add slack term: -slack_step * sum(2^l * s_l)
        for l in range(num_slack_bits):
            cut_poly.add_term(-slack_step_length * (2**l), ('s_opt', k_idx, l))
        
        # Subtract the RHS of the optimality cut
        cut_rhs_poly = BinPol()
        cut_rhs_poly.add_term(data['sub_obj']) # Constant part
        
        for i_idx, i_gen in enumerate(generators):
            for t_idx, t_period in enumerate(time_periods):
                u_term = BinPol().add_term(1, ('u', i_idx, t_idx)).add_term(-u_k.get((i_gen, t_period), 0))
                zON_term = BinPol().add_term(1, ('zon', i_idx, t_idx)).add_term(-zON_k.get((i_gen, t_period), 0))
                zOFF_term = BinPol().add_term(1, ('zoff', i_idx, t_idx)).add_term(-zOFF_k.get((i_gen, t_period), 0))
                
                # u_prev term for ramp-up
                if t_period == 1:
                    u_prev_term_ru = BinPol().add_term(-u_initial[i_gen] if t_period == 1 else -u_k.get((i_gen, t_period-1), 0))
                else:
                    u_prev_term_ru = BinPol().add_term(1, ('u', i_idx, t_idx - 1)).add_term(-u_k.get((i_gen, t_period-1), 0))

                cut_rhs_poly.add(u_term, duals_k['lambda_min'].get((i_gen, t_period), 0.0) * gen_data[i_gen]['Pmin'])
                cut_rhs_poly.add(u_term, duals_k['lambda_max'].get((i_gen, t_period), 0.0) * gen_data[i_gen]['Pmax'])
                cut_rhs_poly.add(u_prev_term_ru, duals_k['lambda_ru'].get((i_gen, t_period), 0.0) * gen_data[i_gen]['Ru'])
                cut_rhs_poly.add(zON_term, duals_k['lambda_ru'].get((i_gen, t_period), 0.0) * gen_data[i_gen]['Rsu'])
                cut_rhs_poly.add(u_term, duals_k['lambda_rd'].get((i_gen, t_period), 0.0) * gen_data[i_gen]['Rd'])
                cut_rhs_poly.add(zOFF_term, duals_k['lambda_rd'].get((i_gen, t_period), 0.0) * gen_data[i_gen]['Rsd'])
        
        full_cut_expression = cut_poly - cut_rhs_poly
        qubo.add(full_cut_expression.power(2), lambda_opt_cut)

    # --- 4. Benders Feasibility Cut Penalties ---
    for k_idx in feas_cut_indices:
        data = iteration_data[k_idx]
        rays_k = data['rays']
        
        # Expression is (-cut_lhs + slack)^2
        cut_poly = BinPol()
        
        # Add slack term: slack_step * sum(2^l * s_l)
        for l in range(num_slack_bits):
            cut_poly.add_term(slack_step_length * (2**l), ('s_feas', k_idx, l))
        
        # Subtract the LHS of the feasibility cut
        cut_lhs_poly = BinPol()
        for i_idx, i_gen in enumerate(generators):
            for t_idx, t_period in enumerate(time_periods):
                cut_lhs_poly.add_term(rays_k['min_power'].get((i_gen, t_period), 0.0) * gen_data[i_gen]['Pmin'], ('u', i_idx, t_idx))
                cut_lhs_poly.add_term(rays_k['max_power'].get((i_gen, t_period), 0.0) * gen_data[i_gen]['Pmax'], ('u', i_idx, t_idx))
                if t_period == 1:
                    cut_lhs_poly.add_term(rays_k['ramp_up'].get((i_gen, t_period), 0.0) * gen_data[i_gen]['Ru'] * u_initial[i_gen])
                else:
                    cut_lhs_poly.add_term(rays_k['ramp_up'].get((i_gen, t_period), 0.0) * gen_data[i_gen]['Ru'], ('u', i_idx, t_idx-1))
                cut_lhs_poly.add_term(rays_k['ramp_up'].get((i_gen, t_period), 0.0) * gen_data[i_gen]['Rsu'], ('zon', i_idx, t_idx))
                cut_lhs_poly.add_term(rays_k['ramp_down'].get((i_gen, t_period), 0.0) * gen_data[i_gen]['Rd'], ('u', i_idx, t_idx))
                cut_lhs_poly.add_term(rays_k['ramp_down'].get((i_gen, t_period), 0.0) * gen_data[i_gen]['Rsd'], ('zoff', i_idx, t_idx))

        for t_idx, t_period in enumerate(time_periods):
            cut_lhs_poly.add_term(rays_k['demand'].get(t_period, 0.0) * demand[t_period])

        full_cut_expression = cut_poly - cut_lhs_poly
        qubo.add(full_cut_expression.power(2), lambda_feas_cut)

    return qubo

def check_master_solution_feasibility_dadk(solution, iteration_data):
    """
    Calculates the raw (unweighted) penalty values for a given dadk solution.
    Returns a dictionary of penalty components.
    """
    u_sol = solution['u'].data.astype(int)
    zON_sol = solution['zon'].data.astype(int)
    zOFF_sol = solution['zoff'].data.astype(int)
    beta_sol = solution['beta'].data.astype(int)
    
    # --- Logic 1 & 2 Penalties ---
    logic1_penalty = 0
    logic2_penalty = 0
    for i_idx, i_gen in enumerate(generators):
        for t_idx, t_period in enumerate(time_periods):
            u_it = u_sol[i_idx, t_idx]
            u_prev = u_initial[i_gen] if t_period == 1 else u_sol[i_idx, t_idx - 1]
            zON_it = zON_sol[i_idx, t_idx]
            zOFF_it = zOFF_sol[i_idx, t_idx]
            logic1_penalty += (u_it - u_prev - zON_it + zOFF_it)**2
            logic2_penalty += zON_it * zOFF_it
            
    # --- Optimality Cut Penalties ---
    opt_cut_penalty = 0
    opt_cut_indices = [k for k, data in enumerate(iteration_data) if data['type'] == 'optimality']
    
    try:
        s_opt_sol = solution['s_opt']
    except KeyError:
        s_opt_sol = None

    for k_idx in opt_cut_indices:
        data = iteration_data[k_idx]
        beta_val = sum((2**j) * beta_sol[j] for j in range(num_beta_bits))
        
        slack_val = 0
        if s_opt_sol is not None:
            slack_val = sum(slack_step_length * (2**l) * s_opt_sol.data[k_idx, l] for l in range(num_slack_bits))
        
        cut_rhs_val = data['sub_obj']
        for i_idx, i_gen in enumerate(generators):
            for t_idx, t_period in enumerate(time_periods):
                u_it = u_sol[i_idx, t_idx]
                u_k_it = data['u_vals'].get((i_gen, t_period), 0)
                u_prev = u_initial[i_gen] if t_period == 1 else u_sol[i_idx, t_idx-1]
                u_k_prev = u_initial[i_gen] if t_period == 1 else data['u_vals'].get((i_gen, t_period-1), 0)
                zON_it = zON_sol[i_idx, t_idx]
                zON_k_it = data['zON_vals'].get((i_gen, t_period), 0)
                zOFF_it = zOFF_sol[i_idx, t_idx]
                zOFF_k_it = data['zOFF_vals'].get((i_gen, t_period), 0)
                duals = data['duals']
                
                cut_rhs_val += duals['lambda_min'].get((i_gen,t_period),0) * gen_data[i_gen]['Pmin'] * (u_it - u_k_it)
                cut_rhs_val += duals['lambda_max'].get((i_gen,t_period),0) * gen_data[i_gen]['Pmax'] * (u_it - u_k_it)
                cut_rhs_val += duals['lambda_ru'].get((i_gen,t_period),0) * (gen_data[i_gen]['Ru']*(u_prev - u_k_prev) + gen_data[i_gen]['Rsu']*(zON_it - zON_k_it))
                cut_rhs_val += duals['lambda_rd'].get((i_gen,t_period),0) * (gen_data[i_gen]['Rd']*(u_it - u_k_it) + gen_data[i_gen]['Rsd']*(zOFF_it - zOFF_k_it))
        
        opt_cut_penalty += (beta_val - slack_val - cut_rhs_val)**2

    # --- Feasibility Cut Penalties ---
    feas_cut_penalty = 0
    feas_cut_indices = [k for k, data in enumerate(iteration_data) if data['type'] == 'feasibility']

    try:
        s_feas_sol = solution['s_feas']
    except KeyError:
        s_feas_sol = None
    
    for k_idx in feas_cut_indices:
        data = iteration_data[k_idx]
        rays_k = data['rays']
        
        slack_val = 0
        if s_feas_sol is not None:
            slack_val = sum(slack_step_length * (2**l) * s_feas_sol.data[k_idx, l] for l in range(num_slack_bits))
        
        cut_lhs_val = 0
        for i_idx, i_gen in enumerate(generators):
            for t_idx, t_period in enumerate(time_periods):
                 u_prev = u_initial[i_gen] if t_period == 1 else u_sol[i_idx, t_idx-1]
                 cut_lhs_val += rays_k['min_power'].get((i_gen, t_period), 0.) * (gen_data[i_gen]['Pmin'] * u_sol[i_idx, t_idx])
                 cut_lhs_val += rays_k['max_power'].get((i_gen, t_period), 0.) * (gen_data[i_gen]['Pmax'] * u_sol[i_idx, t_idx])
                 cut_lhs_val += rays_k['ramp_up'].get((i_gen, t_period), 0.) * (gen_data[i_gen]['Ru'] * u_prev + gen_data[i_gen]['Rsu'] * zON_sol[i_idx, t_idx])
                 cut_lhs_val += rays_k['ramp_down'].get((i_gen, t_period), 0.) * (gen_data[i_gen]['Rd'] * u_sol[i_idx, t_idx] + gen_data[i_gen]['Rsd'] * zOFF_sol[i_idx, t_idx])
        for t_period in time_periods:
            cut_lhs_val += rays_k['demand'].get(t_period, 0.) * demand[t_period]

        feas_cut_penalty += (-cut_lhs_val + slack_val)**2

    return {
        'logic1': logic1_penalty,
        'logic2': logic2_penalty,
        'opt_cuts': opt_cut_penalty,
        'feas_cuts': feas_cut_penalty
    }

# Main Benders Loop, the algorithm.
def main():
    start_time = time.time()
    max_iter = 30
    epsilon = 1 # Tolerance for convergence
    iteration_data = []
    lower_bound = -float('inf')
    upper_bound = float('inf')

    # Initial guess for the master problem variables
    u_current = {}
    zON_current = {}
    zOFF_current = {}

    for t in time_periods:
        for i in generators:
            u_current[i, t] = 1.0
            u_prev_val = u_initial[i] if t == 1 else u_current.get((i, t-1), u_initial[i])
            if u_current[i, t] > 0.5 and u_prev_val < 0.5:
                zON_current[i, t] = 1.0; zOFF_current[i, t] = 0.0
            elif u_current[i, t] < 0.5 and u_prev_val > 0.5:
                zON_current[i, t] = 0.0; zOFF_current[i, t] = 1.0
            else:
                zON_current[i, t] = 0.0; zOFF_current[i, t] = 0.0

    # Uses gurobi_persistent as SP solver
    sub_solver = SolverFactory("gurobi_persistent", solver_io='python')

    print(f"--- Starting Benders Decomposition for UCP ---")
    print(f"Master Solver: dadk QUBOSolverCPU, Subproblem Solver: {sub_solver.name}")
    print(f"Max Iterations: {max_iter}, Tolerance: {epsilon}\n")

    k_iter_count = 0
    best_solution_for_ub_display = None

    for k_loop_idx in range(1, max_iter + 1):
        k_iter_count = k_loop_idx
        print(f"========================= Iteration {k_iter_count} =========================")

        print("--- Solving Subproblem ---")
        subproblem = build_subproblem(u_current, zON_current, zOFF_current)

        # Set the initial conditions for the subproblem
        sub_solver.set_instance(subproblem)
        sub_solver.set_gurobi_param('InfUnbdInfo', 1)
        sub_solver.set_gurobi_param('DualReductions', 0)
        results = sub_solver.solve(tee=False)

        is_infeasible = results.solver.termination_condition == TerminationCondition.infeasible
        sub_obj_val = pyo.value(subproblem.OBJ) if not is_infeasible else float('nan')

        if not is_infeasible:
            print(f"Subproblem Status: Optimal, Objective: {sub_obj_val:.4f}")
            commitment_cost = sum(gen_data[i]['Csu'] * zON_current.get((i,t),0) + gen_data[i]['Csd'] * zOFF_current.get((i,t),0) + gen_data[i]['Cf'] * u_current.get((i,t),0) for i in generators for t in time_periods)
            current_total_cost = commitment_cost + sub_obj_val
            
            logically_sound_for_ub = True
            for i_gen in generators:
                for t_time in time_periods:
                    u_val = u_current.get((i_gen,t_time),0)
                    u_prev_val = u_initial[i_gen] if t_time == 1 else u_current.get((i_gen, t_time-1),0)
                    zon_val = zON_current.get((i_gen,t_time),0)
                    zoff_val = zOFF_current.get((i_gen,t_time),0)
                    if abs((u_val - u_prev_val) - (zon_val - zoff_val)) > 1e-4:
                        logically_sound_for_ub = False; break
                if not logically_sound_for_ub: break
            
            if logically_sound_for_ub and current_total_cost < upper_bound:
                upper_bound = current_total_cost
                best_solution_for_ub_display = {'u_vals': u_current.copy(), 'zON_vals': zON_current.copy(), 'zOFF_vals': zOFF_current.copy(), 'iter': k_iter_count, 'total_cost': upper_bound}
                print(f"New Best Upper Bound (Z_UB): {upper_bound:.4f} (logically sound master solution)")
            
            duals_for_cut = {'lambda_min': {}, 'lambda_max': {}, 'lambda_ru': {}, 'lambda_rd': {}, 'lambda_dem': {}}
            for i in generators:
                for t_p in time_periods:
                    duals_for_cut['lambda_min'][(i,t_p)] = subproblem.dual.get(subproblem.MinPower[i,t_p], 0.0)
                    duals_for_cut['lambda_max'][(i,t_p)] = subproblem.dual.get(subproblem.MaxPower[i,t_p], 0.0)
                    duals_for_cut['lambda_ru'][(i,t_p)]  = subproblem.dual.get(subproblem.RampUp[i,t_p], 0.0)
                    duals_for_cut['lambda_rd'][(i,t_p)]  = subproblem.dual.get(subproblem.RampDown[i,t_p], 0.0)
            for t_p in time_periods:
                duals_for_cut['lambda_dem'][t_p] = subproblem.dual.get(subproblem.Demand[t_p], 0.0)
            
            iteration_data.append({'type': 'optimality', 'sub_obj': sub_obj_val, 'duals': duals_for_cut, 'u_vals': u_current.copy(), 'zON_vals': zON_current.copy(), 'zOFF_vals': zOFF_current.copy()})
        else:
            print("Subproblem Status: INFEASIBLE. Generating Feasibility Cut.")
            rays_for_cut = {'min_power': {}, 'max_power': {}, 'ramp_up': {}, 'ramp_down': {}, 'demand': {}}
            for c in subproblem.component_data_objects(Constraint, active=True):
                ray_val = sub_solver.get_linear_constraint_attr(c, 'FarkasDual') or 0.0
                parent = c.parent_component(); idx = c.index()
                if parent is subproblem.MinPower: rays_for_cut['min_power'][idx] = ray_val
                elif parent is subproblem.MaxPower: rays_for_cut['max_power'][idx] = ray_val
                elif parent is subproblem.RampUp: rays_for_cut['ramp_up'][idx] = ray_val
                elif parent is subproblem.RampDown: rays_for_cut['ramp_down'][idx] = ray_val
                elif parent is subproblem.Demand: rays_for_cut['demand'][idx] = ray_val
            iteration_data.append({'type': 'feasibility', 'rays': rays_for_cut, 'u_vals': u_current.copy(), 'zON_vals': zON_current.copy(), 'zOFF_vals': zOFF_current.copy()})
            
        # Convergence Check
        print(f"Current Lower Bound (Z_LB): {lower_bound:.4f}, Current Upper Bound (Z_UB): {upper_bound:.4f}")
        if upper_bound < float('inf') and lower_bound > -float('inf'):
            gap = (upper_bound - lower_bound)
            print(f"Current Gap: {gap:.6f} (Tolerance: {epsilon})")
            if gap <= epsilon and k_iter_count > 1:
                print("\nConvergence tolerance met.")
                break
        if k_iter_count == max_iter:
            print("\nMaximum iterations reached.")
            break

        # --- Solving Master Problem with dadk ---
        print("\n--- Building and Solving Master Problem with dadk ---")
        master_qubo = build_master_qubo_dadk(iteration_data)
        
        solver = QUBOSolverCPU(
            optimization_method='parallel_tempering',
            number_runs=100,
            number_replicas=100,
            number_iterations=10000,
            scaling_action=ScalingAction.AUTO_SCALING,
        )

        feasible_master_solution_found = False
        for attempt in range(1, 10):
            print(f"dadk master solve attempt {attempt}...")
            solution_list = solver.minimize(master_qubo)
            
            if not solution_list:
                print("dadk solver returned no solutions. Retrying...")
                continue

            solution = solution_list.get_minimum_energy_solution()
            
            # --- Detailed Solution Analysis ---
            penalty_components = check_master_solution_feasibility_dadk(solution, iteration_data)
            
            logic1_pen_val = lambda_logic1 * penalty_components['logic1']
            logic2_pen_val = lambda_logic2 * penalty_components['logic2']
            opt_pen_total_val = lambda_opt_cut * penalty_components['opt_cuts']
            feas_pen_total_val = lambda_feas_cut * penalty_components['feas_cuts']
            total_penalty_calculated = logic1_pen_val + logic2_pen_val + opt_pen_total_val + feas_pen_total_val

            u_sol = solution['u'].data.astype(int)
            zON_sol = solution['zon'].data.astype(int)
            zOFF_sol = solution['zoff'].data.astype(int)
            beta_sol = solution['beta'].data.astype(int)

            commitment_cost_master_sol = sum(
                gen_data[i_gen]['Cf'] * u_sol[i_idx, t_idx] +
                gen_data[i_gen]['Csu'] * zON_sol[i_idx, t_idx] +
                gen_data[i_gen]['Csd'] * zOFF_sol[i_idx, t_idx]
                for i_idx, i_gen in enumerate(generators)
                for t_idx, t_period in enumerate(time_periods))
            
            beta_val_master_sol = sum((2**j) * beta_sol[j] for j in range(num_beta_bits))

            print(f"dadk returned a solution with energy {solution.energy:.4f}")
            print(f"  Commitment Cost part: {commitment_cost_master_sol:.4f}")
            print(f"  Beta Value part: {beta_val_master_sol:.4f}")
            print(f"  Logic1 Penalty part: {logic1_pen_val:.4f}")
            print(f"  Logic2 Penalty part: {logic2_pen_val:.4f}")
            print(f"  Optimality Cuts Penalty part: {opt_pen_total_val:.4f}")
            print(f"  Feasibility Cuts Penalty part: {feas_pen_total_val:.4f}")
            
            # Print decoded slack values
            try:
                s_opt_sol = solution['s_opt']
                opt_cut_indices = [k for k, data in enumerate(iteration_data) if data['type'] == 'optimality']
                for k_idx in opt_cut_indices:
                    decoded_integer_slack = sum((2**l) * s_opt_sol.data[k_idx, l] for l in range(num_slack_bits))
                    actual_slack_value = slack_step_length * decoded_integer_slack
                    print(f"  Optimality Cut {k_idx} Decoded Slack Value: {actual_slack_value:.4f}")
            except KeyError:
                pass 
            
            try:
                s_feas_sol = solution['s_feas']
                feas_cut_indices = [k for k, data in enumerate(iteration_data) if data['type'] == 'feasibility']
                for k_idx in feas_cut_indices:
                    decoded_integer_slack = sum((2**l) * s_feas_sol.data[k_idx, l] for l in range(num_slack_bits))
                    actual_slack_value = slack_step_length * decoded_integer_slack
                    print(f"  Feasibility Cut {k_idx} Decoded Slack Value: {actual_slack_value:.4f}")
            except KeyError:
                pass
            # --- End of Detailed Analysis ---

            if total_penalty_calculated < PENALTY_TOLERANCE:
                print("Solution is feasible (penalties are small).")
                feasible_master_solution_found = True
                
                for i_idx, i_gen in enumerate(generators):
                    for t_idx, t_period in enumerate(time_periods):
                        u_current[(i_gen, t_period)] = float(u_sol[i_idx, t_idx])
                        zON_current[(i_gen, t_period)] = float(zON_sol[i_idx, t_idx])
                        zOFF_current[(i_gen, t_period)] = float(zOFF_sol[i_idx, t_idx])
                
                lower_bound_candidate = commitment_cost_master_sol + beta_val_master_sol
                lower_bound = max(lower_bound, lower_bound_candidate)
                print(f"Updated Lower Bound: {lower_bound:.4f}")
                break 
            else:
                print("Solution is not feasible (penalties are too high). Retrying...")

        if not feasible_master_solution_found:
            print("Master problem solver could not find a feasible solution after 2 tries. Terminating Benders loop.")
            break
            
    end_time = time.time()
    print("\n========================= Benders Terminated =========================")
    print(f"Final Lower Bound (Z_LB): {lower_bound:.4f}")
    print(f"Final Upper Bound (Z_UB): {upper_bound:.4f}")
    final_gap = (upper_bound - lower_bound) if upper_bound != float('inf') and lower_bound != -float('inf') else float('inf')
    print(f"Final Absolute Gap: {final_gap:.6f}")
    print(f"Iterations Performed: {k_iter_count}")
    used_time = end_time - start_time
    print(f"Total Time: {used_time:.2f} seconds")

    if best_solution_for_ub_display:
        print("\n--- Best Feasible Solution Found (leading to best Z_UB in iter {}) ---".format(best_solution_for_ub_display['iter']))
        print(f"Best Total Cost (Upper Bound): {best_solution_for_ub_display['total_cost']:.4f}")
        print("Commitment Schedule (u_it):")
        u_best = best_solution_for_ub_display['u_vals']
        for t_p in time_periods: print(f"  t={t_p}: ", {i: round(u_best.get((i,t_p),0)) for i in generators})
        
        print("\nFinal Dispatch (p_it) for the best UB solution:")
        final_subproblem = build_subproblem(best_solution_for_ub_display['u_vals'],
                                            best_solution_for_ub_display['zON_vals'],
                                            best_solution_for_ub_display['zOFF_vals'])
        final_sub_solver = SolverFactory('gurobi')
        final_sub_results = final_sub_solver.solve(final_subproblem, tee=False)
        if final_sub_results.solver.termination_condition == TerminationCondition.optimal:
            final_sub_obj_resolved = pyo.value(final_subproblem.OBJ)
            final_commit_c_resolved = sum(gen_data[i]['Csu'] * best_solution_for_ub_display['zON_vals'].get((i,t),0) +
                                          gen_data[i]['Csd'] * best_solution_for_ub_display['zOFF_vals'].get((i,t),0) +
                                          gen_data[i]['Cf'] * best_solution_for_ub_display['u_vals'].get((i,t),0)
                                          for i in generators for t in time_periods)
            print(f"  Final Variable Cost (re-solve): {final_sub_obj_resolved:.4f}")
            print(f"  Final Commitment Cost: {final_commit_c_resolved:.2f}")
            print(f"  Final Total Cost (recalculated): {final_commit_c_resolved + final_sub_obj_resolved:.4f}")
            for t_p in time_periods: print(f"    t={t_p}: ", {i: f"{pyo.value(final_subproblem.p[i,t_p]):.2f}" for i in generators})
        else: print(f"Could not re-solve final subproblem for display. Status: {final_sub_results.solver.termination_condition}")
    else: print("\nNo feasible solution matching UB found for final printout.")
     
    return used_time

if __name__ == '__main__':
    main()